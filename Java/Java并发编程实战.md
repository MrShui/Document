# Java并发编程实战

[TOC]

## 困惑

- [ ] 重入

## 第1章 简介

* 线程被称为轻量级进程

## 第2章 线程安全性

### 什么是线程安全

当多个线程访问某个类时，这个类始终都能表现出正确的行为，就称这个类线程安全

### 保证线程安全

* 原子类，`AtomicLong`
* 加锁机制

### `synchronized`

* 静态的`synchronized`方法以`Class`对象作为锁
* 被`synchronized`修饰的方法，其锁是调用改方法的对象
* 称为内置锁

## 第3章 对象的共享

> 在没有同步的情况下，编译期、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整

### 非原子的64位操作

#### 最低安全性

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但这个失效值是由之前的某个线程设置的值，而不是一个随机值。这种安全性保证，叫做最低安全性。

#### 满足最低安全性的变量

非64位变量（64位变量有：`double`，`long`）

#### 保证64位变量的最低安全性

* 加锁
* `volatile`关键字修饰

> | 基本类型 | 位                   |
> | -------- | -------------------- |
> | byte     | 8                    |
> | short    | 16                   |
> | int      | 32                   |
> | long     | 64                   |
> | double   | 64                   |
> | char     | 16                   |
> | double   | 虚拟机规范未明确定义 |
>
> * 1 bit = 1 二进制数据
> * 1 byte = 8 bit（位）
> * 1 字母 = 1 byte = 8 bit（位）
> * 1 汉字 = 2 byte = 16 bit（位）

### 加锁与可见性

加锁不仅仅是互斥行为，好包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读写操作的线程都必须在同一个锁上同步。

